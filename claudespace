#!/usr/bin/env bash
set -euo pipefail

# claudespace: Single-window tmux workspace for Claude Code worktrees
#
# Layout:
#   ┌──────────────┬───────────────┬────────────────┐
#   │ claude       │ claude        │ claude         │
#   │ (worktree 1) │ (worktree 2)  │ (worktree 3)  │
#   ├──────────────┼───────────────┼────────────────┤
#   │ shell        │ shell         │ shell          │
#   │ (worktree 1) │ (worktree 2)  │ (worktree 3)  │
#   └──────────────┴───────────────┴────────────────┘
#
# Usage:
#   claudespace init                  — Create the session and attach
#   claudespace add <name> [branch]   — Add a worktree column (claude + shell)
#   claudespace hide                  — Hide current column (kill panes, keep worktree)
#   claudespace delete <name>         — Delete worktree column, worktree, and branch
#   claudespace move <left|right>     — Move current column left/right (wraps around)
#   claudespace rename <name>         — Rename current column's panes
#   claudespace list                  — List active worktree columns
#   claudespace attach                — Attach to the session
#
# Prerequisites: tmux, git, claude (Claude Code CLI)
#
# Configuration (env vars):
#   CSPACE_SESSION    — tmux session name          (default: claudespace)
#   CSPACE_WT_DIR     — worktree parent directory   (default: ../<repo>__worktrees)

CSPACE_SESSION="${CSPACE_SESSION:-claudespace}"

# --- Helpers ---

repo_root() {
  git rev-parse --show-toplevel 2>/dev/null || {
    echo "Error: not inside a git repository" >&2
    exit 1
  }
}

# Get the main worktree root (works correctly from any worktree)
main_repo_root() {
  git worktree list --porcelain | head -1 | sed 's/^worktree //'
}

repo_name() {
  basename "$(main_repo_root)"
}

# Process .worktreeinclude — copies gitignored files matching patterns to new worktree
# This replicates what Claude Code Desktop does automatically
copy_worktreeinclude() {
  local src_root="$1"   # main worktree / repo root
  local dest="$2"       # new worktree path
  local include_file="$src_root/.worktreeinclude"

  if [[ ! -f "$include_file" ]]; then
    return 0
  fi

  echo "Processing .worktreeinclude patterns..."
  while IFS= read -r pattern || [[ -n "$pattern" ]]; do
    # Skip blank lines and comments
    [[ -z "$pattern" || "$pattern" =~ ^# ]] && continue
    # Trim whitespace
    pattern="$(echo "$pattern" | xargs)"

    # Use git to check if files matching this pattern are ignored
    # Then copy them if they exist in the source
    # Handle both file and directory patterns
    while IFS= read -r -d '' file; do
      # Only copy if the file is gitignored
      if git -C "$src_root" check-ignore -q "$file" 2>/dev/null; then
        local rel="${file#$src_root/}"
        local dest_file="$dest/$rel"
        mkdir -p "$(dirname "$dest_file")"
        if [[ -d "$file" ]]; then
          cp -r "$file" "$dest_file"
        else
          cp "$file" "$dest_file"
        fi
        echo "  Copied: $rel"
      fi
    done < <(cd "$src_root" && find . -path "./.git" -prune -o -name "$(basename "$pattern")" -print0 2>/dev/null \
      | sed "s|^\./|$src_root/|" | tr '\n' '\0')

    # Also try glob expansion directly for simple patterns like .env, .env.local
    local expanded
    expanded=$(cd "$src_root" && ls -d $pattern 2>/dev/null || true)
    for match in $expanded; do
      local full="$src_root/$match"
      if [[ -e "$full" ]] && git -C "$src_root" check-ignore -q "$match" 2>/dev/null; then
        local dest_file="$dest/$match"
        if [[ ! -e "$dest_file" ]]; then
          mkdir -p "$(dirname "$dest_file")"
          cp -r "$full" "$dest_file"
          echo "  Copied: $match"
        fi
      fi
    done
  done < "$include_file"
}

worktree_parent() {
  if [[ -n "${CSPACE_WT_DIR:-}" ]]; then
    echo "$CSPACE_WT_DIR"
  else
    echo "$HOME/.claude-worktrees/$(repo_name)"
  fi
}

worktree_path() {
  echo "$(worktree_parent)/$1"
}

session_exists() {
  tmux has-session -t "$CSPACE_SESSION" 2>/dev/null
}

# Tag a pane with a role via tmux user option (immune to application title changes)
_tag_pane() {
  local pane_id="$1" role="$2"
  tmux set-option -p -t "$pane_id" @cspace "$role"
  tmux select-pane -t "$pane_id" -T "$role"  # also set title for border display
}

# Count current worktree columns by counting claude-tagged panes
column_count() {
  local count
  count=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{@cspace}' \
    | grep -c '^claude:' || true)
  echo "${count:-0}"
}

# Find the claude pane for a given worktree name (by @cspace option)
find_claude_pane() {
  local name="$1"
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ":claude:${name}$" || true; } | head -1 | cut -d: -f1
}

# Find the shell pane for a given worktree name (by @cspace option)
find_shell_pane() {
  local name="$1"
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ":shell:${name}$" || true; } | head -1 | cut -d: -f1
}

# Detect worktree name from current working directory
_detect_worktree_name() {
  local toplevel wt_parent
  toplevel=$(git rev-parse --show-toplevel 2>/dev/null) || return 1
  wt_parent=$(worktree_parent)
  if [[ "$toplevel" == "$wt_parent"/* ]]; then
    basename "$toplevel"
  else
    return 1
  fi
}

# List all worktree directory names
_list_all_worktrees() {
  local wt_dir
  wt_dir=$(worktree_parent)
  if [[ -d "$wt_dir" ]]; then
    ls "$wt_dir" 2>/dev/null
  fi
}

# List active worktree names (have panes in the session)
_list_active_worktrees() {
  if session_exists; then
    tmux list-panes -t "$CSPACE_SESSION:0" -F '#{@cspace}' \
      | grep '^claude:' | sed 's/^claude://'
  fi
}

# List hidden worktrees (exist on disk but no active panes)
_list_hidden_worktrees() {
  local all active name
  all=$(_list_all_worktrees)
  active=$(_list_active_worktrees)
  for name in $all; do
    if ! echo "$active" | grep -qx "$name"; then
      echo "$name"
    fi
  done
}

# --- Commands ---

cmd_init() {
  if session_exists; then
    echo "Session '$CSPACE_SESSION' already exists. Use 'claudespace attach' or 'claudespace add <name>'."
    exit 1
  fi

  local root
  root=$(main_repo_root)
  mkdir -p "$(worktree_parent)"

  # Create session with a single terminal pane
  tmux new-session -d -s "$CSPACE_SESSION" -c "$root" -x "$(tput cols)" -y "$(tput lines)"

  # Prevent applications (claude, shell prompts) from overriding pane/window titles
  tmux set-option -t "$CSPACE_SESSION" allow-rename off
  tmux set-option -t "$CSPACE_SESSION" set-titles off
  tmux set-option -t "$CSPACE_SESSION" allow-set-title off

  _tag_pane "$CSPACE_SESSION:0.0" "terminal"

  echo "Session '$CSPACE_SESSION' created. Use 'claudespace add <name>' to add worktree columns."
  tmux attach-session -t "$CSPACE_SESSION"
}

cmd_add() {
  # Parse --no-worktree flag
  local no_worktree=false
  local args=()
  for arg in "$@"; do
    case "$arg" in
      --no-worktree) no_worktree=true ;;
      *) args+=("$arg") ;;
    esac
  done
  set -- "${args[@]+"${args[@]}"}"

  if [[ -z "${1:-}" ]]; then
    if [[ "$no_worktree" == true ]]; then
      set -- "main"
    else
      echo "Usage: claudespace add [--no-worktree] <name> [base-branch]"
      local hidden
      hidden=$(_list_hidden_worktrees)
      if [[ -n "$hidden" ]]; then
        echo ""
        echo "Hidden worktrees (can re-add):"
        echo "$hidden" | sed 's/^/  /'
      fi
      exit 1
    fi
  fi
  local name="$1"
  local base="${2:-HEAD}"

  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi

  local main_root
  main_root=$(main_repo_root)

  local wt_path
  if [[ "$no_worktree" == true ]]; then
    wt_path="$main_root"
  else
    wt_path=$(worktree_path "$name")

    # Create the git worktree if it doesn't exist
    if [[ ! -d "$wt_path" ]]; then
      echo "Creating worktree: $wt_path (branch: $name from $base)"
      git -C "$main_root" worktree add "$wt_path" -b "$name" "$base" 2>/dev/null || \
      git -C "$main_root" worktree add "$wt_path" "$name" || {
        echo "Error: failed to create worktree" >&2
        exit 1
      }

      # Copy gitignored files listed in .worktreeinclude (matches Desktop behavior)
      copy_worktreeinclude "$main_root" "$wt_path"
    fi
  fi

  local current_cols
  current_cols=$(column_count)

  if [[ "$current_cols" -eq 0 ]]; then
    # First column: look for the terminal pane from init to repurpose
    local term_pane
    term_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
      | { grep ':terminal$' || true; } | head -1 | cut -d: -f1)

    if [[ -n "$term_pane" ]]; then
      # Repurpose the existing terminal pane as the claude pane
      _tag_pane "$term_pane" "claude:${name}"
      tmux send-keys -t "$term_pane" "cd '$wt_path' && claude" C-m

      # Split to create shell pane below
      local shell_pane
      shell_pane=$(tmux split-window -t "$term_pane" -v -p 30 \
        -c "$wt_path" -P -F '#{pane_id}')
      _tag_pane "$shell_pane" "shell:${name}"
    else
      # Fallback: split from the first pane
      local first_pane
      first_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}' | head -1)

      _tag_pane "$first_pane" "claude:${name}"
      tmux send-keys -t "$first_pane" "cd '$wt_path' && claude" C-m

      local shell_pane
      shell_pane=$(tmux split-window -t "$first_pane" -v -p 30 \
        -c "$wt_path" -P -F '#{pane_id}')
      _tag_pane "$shell_pane" "shell:${name}"
    fi
  else
    # Use -fh (full-height horizontal split) to add a new top-level column
    # without disturbing existing column layouts
    local new_claude
    new_claude=$(tmux split-window -t "$CSPACE_SESSION:0" -fh \
      -c "$wt_path" -P -F '#{pane_id}')
    _tag_pane "$new_claude" "claude:${name}"
    tmux send-keys -t "$new_claude" "cd '$wt_path' && claude" C-m

    local new_shell
    new_shell=$(tmux split-window -t "$new_claude" -v -p 30 \
      -c "$wt_path" -P -F '#{pane_id}')
    _tag_pane "$new_shell" "shell:${name}"

    _rebalance_layout
  fi

  echo "Added worktree column '$name' at $wt_path"
}

_rebalance_layout() {
  local num_cols
  num_cols=$(column_count)

  if [[ "$num_cols" -ge 1 ]]; then
    # Balance column widths
    if [[ "$num_cols" -gt 1 ]]; then
      local working_width target_w
      working_width=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_width}')
      target_w=$(( working_width / num_cols ))
      tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
        | { grep ':claude:' || true; } | cut -d: -f1 | while read -r pid; do
          tmux resize-pane -t "$pid" -x "$target_w" 2>/dev/null || true
        done
    fi

    # Balance row heights — give each shell pane 30% of the window height
    local working_height target_shell_h
    working_height=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_height}')
    target_shell_h=$(( working_height * 30 / 100 ))
    tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
      | { grep ':shell:' || true; } | cut -d: -f1 | while read -r pid; do
        tmux resize-pane -t "$pid" -y "$target_shell_h" 2>/dev/null || true
      done
  fi
}

cmd_hide() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Collect all pane IDs in the current column (by matching x position)
  local -a col_pane_ids=()
  while IFS= read -r line; do
    local pid px
    pid="${line%% *}"
    px="${line##* }"
    if [[ "$px" == "$current_x" ]]; then
      col_pane_ids+=("$pid")
    fi
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id} #{pane_left}')

  if [[ ${#col_pane_ids[@]} -eq 0 ]]; then
    echo "Error: could not find panes in current column." >&2
    exit 1
  fi

  # Find the sorted unique column x positions to pick a neighbor for focus
  local -a col_xs=()
  while IFS= read -r x; do
    col_xs+=("$x")
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left}' | sort -un)

  local focus_pane=""
  for i in "${!col_xs[@]}"; do
    if [[ "${col_xs[$i]}" == "$current_x" ]]; then
      # Prefer column to the left, fall back to the right
      if [[ $i -gt 0 ]]; then
        local left_x="${col_xs[$((i - 1))]}"
        focus_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_id}' \
          | awk -v x="$left_x" '$1 == x {print $2; exit}')
      elif [[ $(( i + 1 )) -lt ${#col_xs[@]} ]]; then
        local right_x="${col_xs[$((i + 1))]}"
        focus_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_id}' \
          | awk -v x="$right_x" '$1 == x {print $2; exit}')
      fi
      break
    fi
  done

  # Build a script to: focus neighbor, kill column panes, then rebalance.
  # Must run via tmux run-shell because this script is running inside one of
  # the panes being killed — killing it would terminate the script before
  # rebalance runs.
  local kill_cmds="{ "
  if [[ -n "$focus_pane" ]]; then
    kill_cmds+="tmux select-pane -t $focus_pane; "
  fi
  for pid in "${col_pane_ids[@]}"; do
    kill_cmds+="tmux kill-pane -t $pid; "
  done
  kill_cmds+="claudespace balance; "
  kill_cmds+="} >/dev/null 2>&1"

  tmux run-shell -b "$kill_cmds"
}

cmd_delete() {
  if [[ -z "${1:-}" ]]; then
    echo "Usage: claudespace delete <name>"
    local all
    all=$(_list_all_worktrees)
    if [[ -n "$all" ]]; then
      echo ""
      echo "Worktrees:"
      echo "$all" | sed 's/^/  /'
    fi
    exit 1
  fi
  local name="$1"

  local wt_path
  wt_path=$(worktree_path "$name")

  read -rp "Delete worktree, branch, and panes for '$name'? [y/N] " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "Cancelled."
    return
  fi

  # Remove the worktree (before killing panes, since this script may be running in one)
  if [[ -d "$wt_path" ]]; then
    git worktree remove "$wt_path" --force 2>/dev/null || true
    echo "Worktree removed: $wt_path"
  else
    echo "No worktree found at $wt_path"
  fi

  # Delete the branch
  git branch -D "$name" 2>/dev/null && echo "Branch '$name' deleted." || echo "No branch '$name' found."

  echo "Delete complete for '$name'."

  # Kill tmux panes last (may terminate this script if run from within a pane)
  if session_exists; then
    local claude_pane shell_pane
    claude_pane=$(find_claude_pane "$name")
    shell_pane=$(find_shell_pane "$name")

    if [[ -n "$shell_pane" ]]; then
      tmux kill-pane -t "$shell_pane" 2>/dev/null || true
    fi
    if [[ -n "$claude_pane" ]]; then
      tmux kill-pane -t "$claude_pane" 2>/dev/null || true
    fi

    # Rebalance remaining columns
    if session_exists; then
      _rebalance_layout 2>/dev/null || true
    fi
  fi
}

cmd_list() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  echo "Active worktree columns in '$CSPACE_SESSION':"
  echo
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}  #{@cspace}  #{pane_current_path}  #{pane_current_command}' \
    | { grep -v 'terminal' || true; } \
    | while IFS='  ' read -r id role path cmd; do
        echo "  $role  ($path)  [$cmd]"
      done
  echo
  echo "Columns: $(column_count)"
}

cmd_attach() {
  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi
  tmux attach-session -t "$CSPACE_SESSION"
}

cmd_kill() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi
  tmux kill-session -t "$CSPACE_SESSION"
  echo "Session '$CSPACE_SESSION' killed."
}

cmd_balance() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local num_cols
  num_cols=$(column_count)

  if [[ "$num_cols" -eq 0 ]]; then
    echo "No worktree columns to balance."
    return
  fi

  # Balance column widths
  local working_width target_w
  working_width=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_width}')
  target_w=$(( working_width / num_cols ))
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ':claude:' || true; } | cut -d: -f1 | while read -r pid; do
      tmux resize-pane -t "$pid" -x "$target_w" 2>/dev/null || true
    done

  # Balance row heights — give each shell pane 30% of the window height
  local working_height target_shell_h
  working_height=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_height}')
  target_shell_h=$(( working_height * 30 / 100 ))
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ':shell:' || true; } | cut -d: -f1 | while read -r pid; do
      tmux resize-pane -t "$pid" -y "$target_shell_h" 2>/dev/null || true
    done

  echo "Balanced $num_cols column(s)."
}

cmd_move() {
  local direction="${1:-}"
  if [[ "$direction" != "left" && "$direction" != "right" ]]; then
    echo "Usage: claudespace move <left|right>"
    exit 1
  fi

  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  # Identify columns purely by pane x position
  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Get sorted unique column x positions
  local -a col_xs=()
  while IFS= read -r x; do
    col_xs+=("$x")
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left}' | sort -un)

  local num_cols=${#col_xs[@]}
  if [[ "$num_cols" -lt 2 ]]; then
    echo "Need at least 2 columns to move."
    return
  fi

  # Find current column index
  local idx=-1
  for i in "${!col_xs[@]}"; do
    if [[ "${col_xs[$i]}" == "$current_x" ]]; then
      idx=$i
      break
    fi
  done

  if [[ "$idx" -eq -1 ]]; then
    echo "Error: could not determine current column." >&2
    exit 1
  fi

  # Calculate target index with wrapping
  local target_idx
  if [[ "$direction" == "left" ]]; then
    target_idx=$(( (idx - 1 + num_cols) % num_cols ))
  else
    target_idx=$(( (idx + 1) % num_cols ))
  fi

  local src_x="${col_xs[$idx]}"
  local tgt_x="${col_xs[$target_idx]}"

  # Collect panes in each column, sorted top-to-bottom by y position
  local all_panes
  all_panes=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_top} #{pane_id}')

  local -a src_panes=() tgt_panes=()
  while read -r _ _ pid; do
    src_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$src_x" '$1 == x' | sort -k2 -n)

  while read -r _ _ pid; do
    tgt_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$tgt_x" '$1 == x' | sort -k2 -n)

  # Swap panes row by row (top-to-bottom)
  local rows=${#src_panes[@]}
  [[ ${#tgt_panes[@]} -lt $rows ]] && rows=${#tgt_panes[@]}

  for (( i=0; i<rows; i++ )); do
    tmux swap-pane -s "${src_panes[$i]}" -t "${tgt_panes[$i]}"
  done

  _rebalance_layout

  # Keep focus on the pane the user ran the command from
  tmux select-pane -t "$current_pane"

  echo "Swapped column $((idx+1)) $direction with column $((target_idx+1))."
}

cmd_rename() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    echo "Usage: claudespace rename <name>"
    exit 1
  fi

  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Get panes in current column sorted top-to-bottom
  local all_panes
  all_panes=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_top} #{pane_id}')

  local -a col_panes=()
  while read -r _ _ pid; do
    col_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$current_x" '$1 == x' | sort -k2 -n)

  if [[ ${#col_panes[@]} -eq 0 ]]; then
    echo "Error: could not find panes in current column." >&2
    exit 1
  fi

  # Tag top pane as claude, bottom pane as shell
  _tag_pane "${col_panes[0]}" "claude:${name}"
  if [[ ${#col_panes[@]} -ge 2 ]]; then
    _tag_pane "${col_panes[1]}" "shell:${name}"
  fi

  echo "Renamed column to '$name'."
}

cmd_deploy() {
  local target="${1:-}"

  if [[ -z "$target" ]]; then
    echo "Usage: claudespace deploy <target-branch>"
    echo ""
    echo "Rebases the current worktree onto <target-branch> and fast-forward merges."
    echo "Run from inside a worktree's shell pane."
    exit 1
  fi

  local name
  name=$(_detect_worktree_name) || {
    echo "Error: not inside a claudespace worktree." >&2
    echo "Run this from a worktree's shell pane." >&2
    exit 1
  }

  local main_root
  main_root=$(main_repo_root)

  local wt_path
  wt_path=$(worktree_path "$name")

  # Get the worktree's branch name
  local wt_branch
  wt_branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD)

  # Check for uncommitted changes
  if ! git -C "$wt_path" diff --quiet || ! git -C "$wt_path" diff --cached --quiet; then
    echo "Error: worktree '$name' has uncommitted changes. Commit or stash first." >&2
    exit 1
  fi

  echo "Deploying '$wt_branch' onto '$target'..."

  # Rebase worktree branch onto target
  echo "  Rebasing $wt_branch onto $target..."
  if ! git -C "$wt_path" rebase "$target"; then
    echo "" >&2
    echo "Rebase failed. Resolve conflicts in: $wt_path" >&2
    echo "Then run: cd '$wt_path' && git rebase --continue" >&2
    exit 1
  fi

  # Fast-forward target branch to include worktree commits
  local current_branch
  current_branch=$(git -C "$main_root" rev-parse --abbrev-ref HEAD)

  if [[ "$current_branch" == "$target" ]]; then
    # Main repo is already on target branch — merge directly
    echo "  Fast-forward merging into $target..."
    git -C "$main_root" merge --ff-only "$wt_branch" || {
      echo "Error: fast-forward merge failed" >&2
      exit 1
    }
  else
    # Main repo is on a different branch — update ref without checkout
    echo "  Updating $target ref..."
    local new_tip current_target
    new_tip=$(git -C "$wt_path" rev-parse HEAD)
    current_target=$(git -C "$main_root" rev-parse "$target")

    if git -C "$main_root" merge-base --is-ancestor "$current_target" "$new_tip"; then
      git -C "$main_root" update-ref "refs/heads/$target" "$new_tip" "$current_target"
    else
      echo "Error: cannot fast-forward $target to $wt_branch" >&2
      exit 1
    fi
  fi

  echo ""
  echo "Deployed '$wt_branch' onto '$target'."

  # Push to remote
  echo "  Pushing $target to origin..."
  git -C "$main_root" push origin "$target" || {
    echo "Error: push failed" >&2
    exit 1
  }

  echo "Done. '$target' pushed to origin."
}

# Internal: output completion words for a subcommand
_cmd_complete() {
  local subcmd="${1:-}"
  case "$subcmd" in
    add)     _list_hidden_worktrees ;;
    delete)  _list_all_worktrees ;;
  esac
}

cmd_completions() {
  cat <<'COMP'
_claudespace() {
  local cur prev
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=($(compgen -W "init add hide delete move rename deploy balance list attach kill help completions" -- "$cur"))
    return
  fi

  case "$prev" in
    add|delete)
      local names
      names=$(claudespace _complete "$prev" 2>/dev/null)
      COMPREPLY=($(compgen -W "$names" -- "$cur"))
      ;;
    move)
      COMPREPLY=($(compgen -W "left right" -- "$cur"))
      ;;
  esac
}
complete -F _claudespace claudespace
COMP
}

# --- Main ---

case "${1:-help}" in
  init)         cmd_init ;;
  add)          shift; cmd_add "$@" ;;
  hide)         cmd_hide ;;
  delete)       shift; cmd_delete "$@" ;;
  move)          shift; cmd_move "$@" ;;
  rename)       shift; cmd_rename "$@" ;;
  deploy)       shift; cmd_deploy "$@" ;;
  balance)      cmd_balance ;;
  list)         cmd_list ;;
  attach)       cmd_attach ;;
  kill)         cmd_kill ;;
  completions)  cmd_completions ;;
  _complete)    shift; _cmd_complete "$@" ;;
  help|*)
    cat <<EOF
claudespace — single-window tmux workspace for Claude Code worktrees

Usage:
  claudespace init                  Create session and attach
  claudespace add <name> [branch]   Add a worktree column (claude + shell)
  claudespace add --no-worktree [name]  Add column for repo root (no worktree, default name: main)
  claudespace hide                  Hide current column (kill panes, keep worktree)
  claudespace delete <name>         Delete column, worktree, and branch (prompts y/N)
  claudespace move <left|right>        Move current column left/right (wraps around)
  claudespace rename <name>           Rename current column's panes (claude:<name> + shell:<name>)
  claudespace deploy <target-branch>  Rebase current worktree onto branch and fast-forward merge
  claudespace balance               Resize panes to equal grid size
  claudespace list                  List active worktree columns
  claudespace attach                Attach to the session
  claudespace kill                  Kill the tmux session
  claudespace completions           Output bash completion script

Tab completion:
  Add to your ~/.bashrc or ~/.zshrc:
    eval "\$(claudespace completions)"

Environment:
  CSPACE_SESSION    Session name      (default: claudespace)
  CSPACE_WT_DIR     Worktree parent   (default: ~/.claude-worktrees/<repo>)
EOF
    ;;
esac
