#!/usr/bin/env bash
set -euo pipefail

# claudespace: Single-window tmux workspace for Claude Code worktrees
#
# Layout:
#   ┌──────────────┬───────────────┬────────────────┐
#   │ claude       │ claude        │ claude         │
#   │ (worktree 1) │ (worktree 2)  │ (worktree 3)  │
#   ├──────────────┼───────────────┼────────────────┤
#   │ shell        │ shell         │ shell          │
#   │ (worktree 1) │ (worktree 2)  │ (worktree 3)  │
#   └──────────────┴───────────────┴────────────────┘
#
# Usage:
#   claudespace init                  — Create the session and attach
#   claudespace add <name> [branch]   — Add a worktree column (claude + shell)
#   claudespace hide                  — Hide current column (kill panes, keep worktree)
#   claudespace delete <name>         — Delete worktree column, worktree, and branch
#   claudespace move <left|right>     — Move current column left/right (wraps around)
#   claudespace rename <name>         — Rename current column's panes
#   claudespace balance               — Rebuild column grid (pairs claude+shell, orphans on right)
#   claudespace shrink                — Shrink current column to title width
#   claudespace grow                  — Unshrink current column back to normal width
#   claudespace list                  — List active worktree columns
#   claudespace attach                — Attach to the session
#
# Prerequisites: tmux, git, claude (Claude Code CLI)
#
# Configuration (env vars):
#   CSPACE_SESSION    — tmux session name          (default: claudespace)
#   CSPACE_WT_DIR     — worktree parent directory   (default: ../<repo>__worktrees)

CSPACE_SESSION="${CSPACE_SESSION:-claudespace}"
CSPACE_SHRINK_WIDTH=32

# --- Helpers ---

repo_root() {
  git rev-parse --show-toplevel 2>/dev/null || {
    echo "Error: not inside a git repository" >&2
    exit 1
  }
}

# Get the main worktree root (works correctly from any worktree)
main_repo_root() {
  git worktree list --porcelain | head -1 | sed 's/^worktree //'
}

repo_name() {
  basename "$(main_repo_root)"
}

# Process .worktreeinclude — copies gitignored files matching patterns to new worktree
# This replicates what Claude Code Desktop does automatically
copy_worktreeinclude() {
  local src_root="$1"   # main worktree / repo root
  local dest="$2"       # new worktree path
  local include_file="$src_root/.worktreeinclude"

  if [[ ! -f "$include_file" ]]; then
    return 0
  fi

  echo "Processing .worktreeinclude patterns..."
  while IFS= read -r pattern || [[ -n "$pattern" ]]; do
    # Skip blank lines and comments
    [[ -z "$pattern" || "$pattern" =~ ^# ]] && continue
    # Trim whitespace
    pattern="$(echo "$pattern" | xargs)"

    # Glob expansion for patterns relative to repo root (e.g., .claude/settings.local.json, .env)
    local expanded
    expanded=$(cd "$src_root" && ls -d $pattern 2>/dev/null || true)
    for match in $expanded; do
      local full="$src_root/$match"
      if [[ -e "$full" ]] && git -C "$src_root" check-ignore -q "$match" 2>/dev/null; then
        local dest_file="$dest/$match"
        mkdir -p "$(dirname "$dest_file")"
        cp -r "$full" "$dest_file"
        echo "  Copied: $match"
      fi
    done
  done < "$include_file"
}

worktree_parent() {
  if [[ -n "${CSPACE_WT_DIR:-}" ]]; then
    echo "$CSPACE_WT_DIR"
  else
    echo "$HOME/.claude-worktrees/$(repo_name)"
  fi
}

worktree_path() {
  echo "$(worktree_parent)/$1"
}

session_exists() {
  tmux has-session -t "$CSPACE_SESSION" 2>/dev/null
}

# Tag a pane with a role via tmux user option (immune to application title changes)
_tag_pane() {
  local pane_id="$1" role="$2"
  tmux set-option -p -t "$pane_id" @cspace "$role"
  tmux select-pane -t "$pane_id" -T "$role"  # also set title for border display
}

# Count current worktree columns by counting claude-tagged panes
column_count() {
  local count
  count=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{@cspace}' \
    | grep -c '^claude:' || true)
  echo "${count:-0}"
}

# Find the claude pane for a given worktree name (by @cspace option)
find_claude_pane() {
  local name="$1"
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ":claude:${name}$" || true; } | head -1 | cut -d: -f1
}

# Find the shell pane for a given worktree name (by @cspace option)
find_shell_pane() {
  local name="$1"
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ":shell:${name}$" || true; } | head -1 | cut -d: -f1
}

# Detect worktree name from current working directory
_detect_worktree_name() {
  local toplevel wt_parent
  toplevel=$(git rev-parse --show-toplevel 2>/dev/null) || return 1
  wt_parent=$(worktree_parent)
  if [[ "$toplevel" == "$wt_parent"/* ]]; then
    basename "$toplevel"
  else
    return 1
  fi
}

# List all worktree directory names
_list_all_worktrees() {
  local wt_dir
  wt_dir=$(worktree_parent)
  if [[ -d "$wt_dir" ]]; then
    ls "$wt_dir" 2>/dev/null
  fi
}

# List active worktree names (have panes in the session)
_list_active_worktrees() {
  if session_exists; then
    tmux list-panes -t "$CSPACE_SESSION:0" -F '#{@cspace}' \
      | grep '^claude:' | sed 's/^claude://'
  fi
}

# List hidden worktrees (exist on disk but no active panes)
_list_hidden_worktrees() {
  local all active name
  all=$(_list_all_worktrees)
  active=$(_list_active_worktrees)
  for name in $all; do
    if ! echo "$active" | grep -qx "$name"; then
      echo "$name"
    fi
  done
}

# --- Commands ---

cmd_init() {
  if session_exists; then
    echo "Session '$CSPACE_SESSION' already exists. Use 'claudespace attach' or 'claudespace add <name>'."
    exit 1
  fi

  local root
  root=$(main_repo_root)
  mkdir -p "$(worktree_parent)"

  # Create session with a single terminal pane
  tmux new-session -d -s "$CSPACE_SESSION" -c "$root" -x "$(tput cols)" -y "$(tput lines)"

  # Prevent applications (claude, shell prompts) from overriding pane/window titles
  tmux set-option -t "$CSPACE_SESSION" allow-rename off
  tmux set-option -t "$CSPACE_SESSION" set-titles off
  tmux set-option -t "$CSPACE_SESSION" allow-set-title off

  _tag_pane "$CSPACE_SESSION:0.0" "terminal"

  echo "Session '$CSPACE_SESSION' created. Use 'claudespace add <name>' to add worktree columns."
  tmux attach-session -t "$CSPACE_SESSION"
}

cmd_add() {
  # Parse --no-worktree flag
  local no_worktree=false
  local args=()
  for arg in "$@"; do
    case "$arg" in
      --no-worktree) no_worktree=true ;;
      *) args+=("$arg") ;;
    esac
  done
  set -- "${args[@]+"${args[@]}"}"

  if [[ -z "${1:-}" ]]; then
    if [[ "$no_worktree" == true ]]; then
      set -- "main"
    else
      echo "Usage: claudespace add [--no-worktree] <name> [base-branch]"
      local hidden
      hidden=$(_list_hidden_worktrees)
      if [[ -n "$hidden" ]]; then
        echo ""
        echo "Hidden worktrees (can re-add):"
        echo "$hidden" | sed 's/^/  /'
      fi
      exit 1
    fi
  fi
  local name="$1"
  local base="${2:-HEAD}"

  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi

  local main_root
  main_root=$(main_repo_root)

  local wt_path
  if [[ "$no_worktree" == true ]]; then
    wt_path="$main_root"
  else
    wt_path=$(worktree_path "$name")

    # Create the git worktree if it doesn't exist
    if [[ ! -d "$wt_path" ]]; then
      echo "Creating worktree: $wt_path (branch: $name from $base)"
      git -C "$main_root" worktree add "$wt_path" -b "$name" "$base" 2>/dev/null || \
      git -C "$main_root" worktree add "$wt_path" "$name" || {
        echo "Error: failed to create worktree" >&2
        exit 1
      }

      # Copy gitignored files listed in .worktreeinclude (matches Desktop behavior)
      copy_worktreeinclude "$main_root" "$wt_path"
    fi
  fi

  local current_cols
  current_cols=$(column_count)

  if [[ "$current_cols" -eq 0 ]]; then
    # First column: look for the terminal pane from init to repurpose
    local term_pane
    term_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
      | { grep ':terminal$' || true; } | head -1 | cut -d: -f1)

    if [[ -n "$term_pane" ]]; then
      # Repurpose the existing terminal pane as the claude pane
      _tag_pane "$term_pane" "claude:${name}"
      tmux send-keys -t "$term_pane" "cd '$wt_path' && claude" C-m

      # Split to create shell pane below
      local shell_pane
      shell_pane=$(tmux split-window -t "$term_pane" -v -p 30 \
        -c "$wt_path" -P -F '#{pane_id}')
      _tag_pane "$shell_pane" "shell:${name}"
    else
      # Fallback: split from the first pane
      local first_pane
      first_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}' | head -1)

      _tag_pane "$first_pane" "claude:${name}"
      tmux send-keys -t "$first_pane" "cd '$wt_path' && claude" C-m

      local shell_pane
      shell_pane=$(tmux split-window -t "$first_pane" -v -p 30 \
        -c "$wt_path" -P -F '#{pane_id}')
      _tag_pane "$shell_pane" "shell:${name}"
    fi
  else
    # Use -fh (full-height horizontal split) to add a new top-level column
    # without disturbing existing column layouts
    local new_claude
    new_claude=$(tmux split-window -t "$CSPACE_SESSION:0" -fh \
      -c "$wt_path" -P -F '#{pane_id}')
    _tag_pane "$new_claude" "claude:${name}"
    tmux send-keys -t "$new_claude" "cd '$wt_path' && claude" C-m

    local new_shell
    new_shell=$(tmux split-window -t "$new_claude" -v -p 30 \
      -c "$wt_path" -P -F '#{pane_id}')
    _tag_pane "$new_shell" "shell:${name}"

    _rebalance
  fi

  # Notify Slack bridge of new session (background, fail-silent)
  local _bridge_pane
  _bridge_pane=$(find_claude_pane "$name")
  if [[ -n "$_bridge_pane" ]]; then
    curl -sf -X POST "http://localhost:${BRIDGE_PORT:-7890}/thread" \
      -H 'Content-Type: application/json' \
      -d "{\"pane_id\":\"${_bridge_pane}\",\"name\":\"${name}\"}" \
      >/dev/null 2>&1 &
  fi

  echo "Added worktree column '$name' at $wt_path"
}

# Rebalance all columns: shrunk columns get CSPACE_SHRINK_WIDTH,
# non-shrunk columns equally divide the remaining space.
# Also balances row heights (shell panes get 30%).
_rebalance() {
  local num_cols
  num_cols=$(column_count)
  [[ "$num_cols" -ge 1 ]] || return

  local working_width
  working_width=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_width}')

  # Collect all claude panes sorted left-to-right by x position
  local -a pane_ids=() pane_shrunk=()
  while IFS='|' read -r pid _px tag shrunk; do
    [[ "$tag" == claude:* ]] || continue
    pane_ids+=("$pid")
    pane_shrunk+=("$shrunk")
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" \
    -F '#{pane_id}|#{pane_left}|#{@cspace}|#{@cspace_shrunk}' | sort -t'|' -k2 -n)

  # Calculate target width for non-shrunk columns
  local shrunk_width=0 nonshrunk_count=0
  for i in "${!pane_ids[@]}"; do
    if [[ "${pane_shrunk[$i]}" == "1" ]]; then
      shrunk_width=$(( shrunk_width + CSPACE_SHRINK_WIDTH ))
    else
      nonshrunk_count=$(( nonshrunk_count + 1 ))
    fi
  done

  local target_nonshrunk=0
  if [[ "$nonshrunk_count" -gt 0 ]]; then
    local separators=$(( num_cols - 1 ))
    local available=$(( working_width - shrunk_width - separators ))
    target_nonshrunk=$(( available / nonshrunk_count ))
  fi

  # Resize all columns except the last from left to right.
  # Each resize adjusts the right neighbor, so going left-to-right
  # and skipping the last (which absorbs rounding) avoids cascading errors.
  local last=$(( ${#pane_ids[@]} - 1 ))
  for i in "${!pane_ids[@]}"; do
    [[ $i -eq $last ]] && break
    local target_w
    if [[ "${pane_shrunk[$i]}" == "1" ]]; then
      target_w=$CSPACE_SHRINK_WIDTH
    else
      target_w=$target_nonshrunk
    fi
    tmux resize-pane -t "${pane_ids[$i]}" -x "$target_w" 2>/dev/null || true
  done

  # Balance row heights — give each shell pane 30% of the window height
  local working_height target_shell_h
  working_height=$(tmux display-message -t "$CSPACE_SESSION:0" -p '#{window_height}')
  target_shell_h=$(( working_height * 30 / 100 ))
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}:#{@cspace}' \
    | { grep ':shell:' || true; } | cut -d: -f1 | while read -r pid; do
      tmux resize-pane -t "$pid" -y "$target_shell_h" 2>/dev/null || true
    done
}

cmd_hide() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Collect all pane IDs in the current column (by matching x position)
  local -a col_pane_ids=()
  while IFS= read -r line; do
    local pid px
    pid="${line%% *}"
    px="${line##* }"
    if [[ "$px" == "$current_x" ]]; then
      col_pane_ids+=("$pid")
    fi
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id} #{pane_left}')

  if [[ ${#col_pane_ids[@]} -eq 0 ]]; then
    echo "Error: could not find panes in current column." >&2
    exit 1
  fi

  # Find the sorted unique column x positions to pick a neighbor for focus
  local -a col_xs=()
  while IFS= read -r x; do
    col_xs+=("$x")
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left}' | sort -un)

  local focus_pane=""
  for i in "${!col_xs[@]}"; do
    if [[ "${col_xs[$i]}" == "$current_x" ]]; then
      # Prefer column to the left, fall back to the right
      if [[ $i -gt 0 ]]; then
        local left_x="${col_xs[$((i - 1))]}"
        focus_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_id}' \
          | awk -v x="$left_x" '$1 == x {print $2; exit}')
      elif [[ $(( i + 1 )) -lt ${#col_xs[@]} ]]; then
        local right_x="${col_xs[$((i + 1))]}"
        focus_pane=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_id}' \
          | awk -v x="$right_x" '$1 == x {print $2; exit}')
      fi
      break
    fi
  done

  # Notify Slack bridge before killing panes (background, fail-silent)
  for pid in "${col_pane_ids[@]}"; do
    local _htag
    _htag=$(tmux display-message -p -t "$pid" '#{@cspace}' 2>/dev/null || true)
    if [[ "$_htag" =~ ^claude: ]]; then
      curl -sf -X POST "http://localhost:${BRIDGE_PORT:-7890}/close" \
        -H 'Content-Type: application/json' \
        -d "{\"pane_id\":\"${pid}\",\"name\":\"${_htag#claude:}\"}" \
        >/dev/null 2>&1 &
      break
    fi
  done

  # Build a script to: focus neighbor, kill column panes, then rebalance.
  # Must run via tmux run-shell because this script is running inside one of
  # the panes being killed — killing it would terminate the script before
  # rebalance runs.
  local kill_cmds="{ "
  if [[ -n "$focus_pane" ]]; then
    kill_cmds+="tmux select-pane -t $focus_pane; "
  fi
  for pid in "${col_pane_ids[@]}"; do
    kill_cmds+="tmux kill-pane -t $pid; "
  done
  kill_cmds+="claudespace _rebalance; "
  kill_cmds+="} >/dev/null 2>&1"

  tmux run-shell -b "$kill_cmds"
}

cmd_delete() {
  if [[ -z "${1:-}" ]]; then
    echo "Usage: claudespace delete <name>"
    local all
    all=$(_list_all_worktrees)
    if [[ -n "$all" ]]; then
      echo ""
      echo "Worktrees:"
      echo "$all" | sed 's/^/  /'
    fi
    exit 1
  fi
  local name="$1"

  local wt_path
  wt_path=$(worktree_path "$name")

  read -rp "Delete worktree, branch, and panes for '$name'? [y/N] " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "Cancelled."
    return
  fi

  # Remove the worktree (before killing panes, since this script may be running in one)
  if [[ -d "$wt_path" ]]; then
    git worktree remove "$wt_path" --force 2>/dev/null || true
    echo "Worktree removed: $wt_path"
  else
    echo "No worktree found at $wt_path"
  fi

  # Delete the branch
  git branch -D "$name" 2>/dev/null && echo "Branch '$name' deleted." || echo "No branch '$name' found."

  echo "Delete complete for '$name'."

  # Notify Slack bridge (background, fail-silent) — permanent removes persistent thread mapping
  if session_exists; then
    local _dpane
    _dpane=$(find_claude_pane "$name")
    if [[ -n "$_dpane" ]]; then
      curl -sf -X POST "http://localhost:${BRIDGE_PORT:-7890}/close" \
        -H 'Content-Type: application/json' \
        -d "{\"pane_id\":\"${_dpane}\",\"name\":\"${name}\",\"permanent\":true}" \
        >/dev/null 2>&1 &
    fi
  fi

  # Kill tmux panes last (may terminate this script if run from within a pane)
  if session_exists; then
    local claude_pane shell_pane
    claude_pane=$(find_claude_pane "$name")
    shell_pane=$(find_shell_pane "$name")

    if [[ -n "$shell_pane" ]]; then
      tmux kill-pane -t "$shell_pane" 2>/dev/null || true
    fi
    if [[ -n "$claude_pane" ]]; then
      tmux kill-pane -t "$claude_pane" 2>/dev/null || true
    fi

    # Rebalance remaining columns
    if session_exists; then
      _rebalance 2>/dev/null || true
    fi
  fi
}

cmd_list() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  echo "Active worktree columns in '$CSPACE_SESSION':"
  echo
  tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}  #{@cspace}  #{pane_current_path}  #{pane_current_command}' \
    | { grep -v 'terminal' || true; } \
    | while IFS='  ' read -r id role path cmd; do
        echo "  $role  ($path)  [$cmd]"
      done
  echo
  echo "Columns: $(column_count)"
}

cmd_attach() {
  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi
  tmux attach-session -t "$CSPACE_SESSION"
}

cmd_kill() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi
  tmux kill-session -t "$CSPACE_SESSION"
  echo "Session '$CSPACE_SESSION' killed."
}

cmd_balance() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  # --- Collect all panes in window 0 and categorize by @cspace tag ---
  # Using parallel arrays (bash 3.2 compatible — no associative arrays)
  local -a claude_names=() claude_pids=()
  local -a shell_names=() shell_pids=()
  local -a other_pids=()
  while IFS='|' read -r pid tag; do
    case "$tag" in
      claude:*)
        claude_names+=("${tag#claude:}")
        claude_pids+=("$pid")
        ;;
      shell:*)
        shell_names+=("${tag#shell:}")
        shell_pids+=("$pid")
        ;;
      *)
        other_pids+=("$pid")
        ;;
    esac
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}|#{@cspace}')

  # --- Build paired columns (claude+shell with matching name) and orphan list ---
  # paired_* arrays are index-aligned: paired_names[i] / paired_cpids[i] / paired_spids[i]
  local -a paired_names=() paired_cpids=() paired_spids=()
  local -a orphan_panes=()

  local ci si
  for ci in "${!claude_names[@]}"; do
    local cname="${claude_names[$ci]}"
    local matched_spid=""
    for si in "${!shell_names[@]}"; do
      if [[ "${shell_names[$si]}" == "$cname" ]]; then
        matched_spid="${shell_pids[$si]}"
        break
      fi
    done
    if [[ -n "$matched_spid" ]]; then
      paired_names+=("$cname")
      paired_cpids+=("${claude_pids[$ci]}")
      paired_spids+=("$matched_spid")
    else
      orphan_panes+=("${claude_pids[$ci]}")
    fi
  done

  # Find orphan shell panes (no matching claude)
  for si in "${!shell_names[@]}"; do
    local sname="${shell_names[$si]}"
    local has_claude=""
    for ci in "${!claude_names[@]}"; do
      if [[ "${claude_names[$ci]}" == "$sname" ]]; then
        has_claude=1
        break
      fi
    done
    if [[ -z "$has_claude" ]]; then
      orphan_panes+=("${shell_pids[$si]}")
    fi
  done
  # Append other_pids to orphans (guard empty array for bash 3.2 + set -u)
  if [[ ${#other_pids[@]} -gt 0 ]]; then
    orphan_panes+=("${other_pids[@]}")
  fi

  local total_paired=${#paired_names[@]}
  local total_orphans=${#orphan_panes[@]}
  local total_panes=$(( total_paired * 2 + total_orphans ))

  if [[ $total_panes -le 1 ]]; then
    echo "Nothing to rebalance (only $total_panes pane)."
    return
  fi

  # Sort paired columns by current x position to preserve left-to-right order
  if [[ $total_paired -gt 1 ]]; then
    local -a new_names=() new_cpids=() new_spids=()
    while IFS='|' read -r _ idx; do
      new_names+=("${paired_names[$idx]}")
      new_cpids+=("${paired_cpids[$idx]}")
      new_spids+=("${paired_spids[$idx]}")
    done < <(
      for i in "${!paired_names[@]}"; do
        local px
        px=$(tmux display-message -t "${paired_cpids[$i]}" -p '#{pane_left}' 2>/dev/null || echo "9999")
        echo "${px}|${i}"
      done | sort -t'|' -k1 -n
    )
    paired_names=("${new_names[@]}")
    paired_cpids=("${new_cpids[@]}")
    paired_spids=("${new_spids[@]}")
  fi

  # --- Choose anchor pane (first claude pane, or first orphan if no pairs) ---
  local anchor_pane
  if [[ $total_paired -gt 0 ]]; then
    anchor_pane="${paired_cpids[0]}"
  else
    anchor_pane="${orphan_panes[0]}"
  fi

  # --- Break all non-anchor panes out to temporary windows ---
  local -a break_panes=()
  for i in "${!paired_names[@]}"; do
    break_panes+=("${paired_cpids[$i]}" "${paired_spids[$i]}")
  done
  if [[ ${#orphan_panes[@]} -gt 0 ]]; then
    break_panes+=("${orphan_panes[@]}")
  fi

  for pid in "${break_panes[@]}"; do
    [[ "$pid" == "$anchor_pane" ]] && continue
    tmux break-pane -d -s "$pid" 2>/dev/null || true
  done

  # --- Rebuild the grid: paired columns, then orphan column on right ---
  if [[ $total_paired -gt 0 ]]; then
    # First paired column: anchor (claude) is already in window 0, join shell below
    tmux join-pane -v -s "${paired_spids[0]}" -t "$anchor_pane"

    # Additional paired columns: join to the right as full-height columns
    for (( i=1; i<total_paired; i++ )); do
      tmux join-pane -fh -s "${paired_cpids[$i]}" -t "$anchor_pane"
      tmux join-pane -v -s "${paired_spids[$i]}" -t "${paired_cpids[$i]}"
    done
  fi

  # Orphan column on the far right
  if [[ $total_orphans -gt 0 ]]; then
    local start=0
    # If no paired columns, anchor is first orphan — already in window 0
    [[ $total_paired -eq 0 ]] && start=1

    for (( i=start; i<total_orphans; i++ )); do
      if [[ $i -eq $start ]]; then
        # First orphan in column: join as new column on the right
        tmux join-pane -fh -s "${orphan_panes[$i]}" -t "$anchor_pane"
      else
        # Subsequent orphans: stack below the previous one
        tmux join-pane -v -s "${orphan_panes[$i]}" -t "${orphan_panes[$((i-1))]}"
      fi
    done
  fi

  # --- Clear shrunk tags and rebalance sizes ---
  for i in "${!paired_cpids[@]}"; do
    tmux set-option -pu -t "${paired_cpids[$i]}" @cspace_shrunk 2>/dev/null || true
  done

  _rebalance

  local msg="Rebuilt grid: $total_paired paired column(s)"
  [[ $total_orphans -gt 0 ]] && msg+=", $total_orphans orphan pane(s) on right"
  echo "$msg."
}

cmd_shrink() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Find the claude pane in the current column (by matching x position)
  local claude_pane=""
  while IFS='|' read -r pid px tag; do
    if [[ "$px" == "$current_x" && "$tag" == claude:* ]]; then
      claude_pane="$pid"
      break
    fi
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}|#{pane_left}|#{@cspace}')

  if [[ -z "$claude_pane" ]]; then
    echo "Error: no claude pane found in current column." >&2
    exit 1
  fi

  local min_width=$CSPACE_SHRINK_WIDTH

  tmux resize-pane -t "$claude_pane" -x "$min_width" 2>/dev/null || true
  tmux set-option -p -t "$claude_pane" @cspace_shrunk 1

  # Rebalance non-shrunk columns to fill the freed space
  _rebalance

  echo "Shrunk column to ${min_width} chars wide."
}

cmd_grow() {
  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Find the claude pane in the current column (by matching x position)
  local claude_pane="" is_shrunk=""
  while IFS='|' read -r pid px tag shrunk; do
    if [[ "$px" == "$current_x" && "$tag" == claude:* ]]; then
      claude_pane="$pid"
      is_shrunk="$shrunk"
      break
    fi
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_id}|#{pane_left}|#{@cspace}|#{@cspace_shrunk}')

  if [[ -z "$claude_pane" ]]; then
    echo "Error: no claude pane found in current column." >&2
    exit 1
  fi

  if [[ "$is_shrunk" != "1" ]]; then
    echo "Column is not shrunk."
    return
  fi

  # Clear shrunk tag and rebalance
  tmux set-option -pu -t "$claude_pane" @cspace_shrunk 2>/dev/null || true
  _rebalance

  echo "Grew column back to normal width."
}

cmd_move() {
  local direction="${1:-}"
  if [[ "$direction" != "left" && "$direction" != "right" ]]; then
    echo "Usage: claudespace move <left|right>"
    exit 1
  fi

  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  # Identify columns purely by pane x position
  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Get sorted unique column x positions
  local -a col_xs=()
  while IFS= read -r x; do
    col_xs+=("$x")
  done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left}' | sort -un)

  local num_cols=${#col_xs[@]}
  if [[ "$num_cols" -lt 2 ]]; then
    echo "Need at least 2 columns to move."
    return
  fi

  # Find current column index
  local idx=-1
  for i in "${!col_xs[@]}"; do
    if [[ "${col_xs[$i]}" == "$current_x" ]]; then
      idx=$i
      break
    fi
  done

  if [[ "$idx" -eq -1 ]]; then
    echo "Error: could not determine current column." >&2
    exit 1
  fi

  # Calculate target index with wrapping
  local target_idx
  if [[ "$direction" == "left" ]]; then
    target_idx=$(( (idx - 1 + num_cols) % num_cols ))
  else
    target_idx=$(( (idx + 1) % num_cols ))
  fi

  local src_x="${col_xs[$idx]}"
  local tgt_x="${col_xs[$target_idx]}"

  # Collect panes in each column, sorted top-to-bottom by y position
  local all_panes
  all_panes=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_top} #{pane_id}')

  local -a src_panes=() tgt_panes=()
  while read -r _ _ pid; do
    src_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$src_x" '$1 == x' | sort -k2 -n)

  while read -r _ _ pid; do
    tgt_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$tgt_x" '$1 == x' | sort -k2 -n)

  # Swap panes row by row (top-to-bottom)
  local rows=${#src_panes[@]}
  [[ ${#tgt_panes[@]} -lt $rows ]] && rows=${#tgt_panes[@]}

  for (( i=0; i<rows; i++ )); do
    tmux swap-pane -s "${src_panes[$i]}" -t "${tgt_panes[$i]}"
  done

  _rebalance

  # Keep focus on the pane the user ran the command from
  tmux select-pane -t "$current_pane"

  echo "Swapped column $((idx+1)) $direction with column $((target_idx+1))."
}

cmd_rename() {
  local name="${1:-}"
  if [[ -z "$name" ]]; then
    echo "Usage: claudespace rename <name>"
    exit 1
  fi

  if ! session_exists; then
    echo "No session found." >&2
    exit 1
  fi

  local current_pane
  current_pane="${TMUX_PANE:-$(tmux display-message -p '#{pane_id}')}"

  local current_x
  current_x=$(tmux display-message -t "$current_pane" -p '#{pane_left}')

  # Get panes in current column sorted top-to-bottom
  local all_panes
  all_panes=$(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{pane_left} #{pane_top} #{pane_id}')

  local -a col_panes=()
  while read -r _ _ pid; do
    col_panes+=("$pid")
  done < <(echo "$all_panes" | awk -v x="$current_x" '$1 == x' | sort -k2 -n)

  if [[ ${#col_panes[@]} -eq 0 ]]; then
    echo "Error: could not find panes in current column." >&2
    exit 1
  fi

  # Tag top pane as claude, bottom pane as shell
  _tag_pane "${col_panes[0]}" "claude:${name}"
  if [[ ${#col_panes[@]} -ge 2 ]]; then
    _tag_pane "${col_panes[1]}" "shell:${name}"
  fi

  echo "Renamed column to '$name'."
}

cmd_deploy() {
  local target="${1:-}"

  if [[ -z "$target" ]]; then
    echo "Usage: claudespace deploy <target-branch>"
    echo ""
    echo "Rebases the current worktree onto <target-branch> and fast-forward merges."
    echo "Run from inside a worktree's shell pane."
    exit 1
  fi

  local name
  name=$(_detect_worktree_name) || {
    echo "Error: not inside a claudespace worktree." >&2
    echo "Run this from a worktree's shell pane." >&2
    exit 1
  }

  local main_root
  main_root=$(main_repo_root)

  local wt_path
  wt_path=$(worktree_path "$name")

  # Get the worktree's branch name
  local wt_branch
  wt_branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD)

  # Check for uncommitted changes
  if ! git -C "$wt_path" diff --quiet || ! git -C "$wt_path" diff --cached --quiet; then
    echo "Error: worktree '$name' has uncommitted changes. Commit or stash first." >&2
    exit 1
  fi

  echo "Deploying '$wt_branch' onto '$target'..."

  # Fetch latest from origin so we rebase onto up-to-date target
  echo "  Fetching origin/$target..."
  git -C "$main_root" fetch origin "$target" || {
    echo "Error: failed to fetch origin/$target" >&2
    exit 1
  }

  # Rebase worktree branch onto target
  echo "  Rebasing $wt_branch onto origin/$target..."
  if ! git -C "$wt_path" rebase "origin/$target"; then
    echo "" >&2
    echo "Rebase failed. Resolve conflicts in: $wt_path" >&2
    echo "Then run: cd '$wt_path' && git rebase --continue" >&2
    exit 1
  fi

  # Fast-forward target branch to include worktree commits
  local current_branch
  current_branch=$(git -C "$main_root" rev-parse --abbrev-ref HEAD)

  if [[ "$current_branch" == "$target" ]]; then
    # Main repo is already on target branch — merge directly
    echo "  Fast-forward merging into $target..."
    git -C "$main_root" merge --ff-only "$wt_branch" || {
      echo "Error: fast-forward merge failed" >&2
      exit 1
    }
  else
    # Main repo is on a different branch — update ref without checkout
    echo "  Updating $target ref..."
    local new_tip origin_target
    new_tip=$(git -C "$wt_path" rev-parse HEAD)
    origin_target=$(git -C "$main_root" rev-parse "origin/$target")

    if git -C "$main_root" merge-base --is-ancestor "$origin_target" "$new_tip"; then
      git -C "$main_root" update-ref "refs/heads/$target" "$new_tip"
    else
      echo "Error: cannot fast-forward $target to $wt_branch" >&2
      exit 1
    fi
  fi

  echo ""
  echo "Deployed '$wt_branch' onto '$target'."

  # Push to remote
  echo "  Pushing $target to origin..."
  git -C "$main_root" push origin "$target" || {
    echo "Error: push failed" >&2
    exit 1
  }

  echo "Done. '$target' pushed to origin."
}

cmd_slack() {
  local action="${1:-start}"

  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi

  local script_dir
  script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
  local bridge_dir="$script_dir/claude-slack-bridge"

  if [[ ! -d "$bridge_dir" ]]; then
    echo "Error: bridge not found at $bridge_dir" >&2
    exit 1
  fi

  local window_name="slack-bridge"

  case "$action" in
    start)
      # Check if window already exists
      if tmux list-windows -t "$CSPACE_SESSION" -F '#{window_name}' 2>/dev/null \
          | grep -qx "$window_name"; then
        echo "Slack bridge is already running. Use 'claudespace slack stop' to stop it."
        return
      fi

      if [[ ! -d "$bridge_dir/node_modules" ]]; then
        echo "Error: run 'npm install' in $bridge_dir first." >&2
        exit 1
      fi

      tmux new-window -t "$CSPACE_SESSION" -n "$window_name" -c "$bridge_dir" "npm run dev"
      echo "Slack bridge started in tmux window '$window_name'."
      ;;
    stop)
      if tmux list-windows -t "$CSPACE_SESSION" -F '#{window_name}' 2>/dev/null \
          | grep -qx "$window_name"; then
        tmux kill-window -t "$CSPACE_SESSION:$window_name"
        echo "Slack bridge stopped."
      else
        echo "Slack bridge is not running."
      fi
      ;;
    *)
      echo "Usage: claudespace slack [start|stop]"
      exit 1
      ;;
  esac
}

cmd_connect() {
  if ! session_exists; then
    echo "No session found. Run 'claudespace init' first." >&2
    exit 1
  fi

  # Check bridge health
  if ! curl -sf "http://localhost:${BRIDGE_PORT:-7890}/health" >/dev/null 2>&1; then
    echo "Slack bridge is not running. Start it with 'claudespace slack'." >&2
    exit 1
  fi

  local names=()
  if [[ $# -gt 0 ]]; then
    names=("$@")
  else
    # Connect all active claude panes
    while IFS= read -r tag; do
      [[ -n "$tag" ]] && names+=("${tag#claude:}")
    done < <(tmux list-panes -t "$CSPACE_SESSION:0" -F '#{@cspace}' \
      | grep '^claude:')
  fi

  if [[ ${#names[@]} -eq 0 ]]; then
    echo "No active columns to connect."
    return
  fi

  for name in "${names[@]}"; do
    local pane_id
    pane_id=$(find_claude_pane "$name")
    if [[ -z "$pane_id" ]]; then
      echo "$name: no active pane found (skipped)"
      continue
    fi

    local result
    result=$(curl -sf -X POST "http://localhost:${BRIDGE_PORT:-7890}/connect" \
      -H 'Content-Type: application/json' \
      -d "{\"pane_id\":\"${pane_id}\",\"name\":\"${name}\"}" 2>&1) || {
      echo "$name: bridge error"
      continue
    }

    if echo "$result" | grep -q '"reconnected":true'; then
      echo "$name: reconnected to existing thread"
    else
      echo "$name: new thread created"
    fi
  done
}

# Internal: rebalance entry point for tmux run-shell
cmd__rebalance() {
  if ! session_exists; then
    return
  fi
  _rebalance
}

# Internal: output completion words for a subcommand
_cmd_complete() {
  local subcmd="${1:-}"
  case "$subcmd" in
    add)     _list_hidden_worktrees ;;
    delete)  _list_all_worktrees ;;
    connect) _list_active_worktrees ;;
  esac
}

cmd_completions() {
  cat <<'COMP'
_claudespace() {
  local cur prev
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"

  if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=($(compgen -W "init add hide delete move rename deploy shrink grow balance list attach kill slack connect help completions" -- "$cur"))
    return
  fi

  case "$prev" in
    add|delete|connect)
      local names
      names=$(claudespace _complete "$prev" 2>/dev/null)
      COMPREPLY=($(compgen -W "$names" -- "$cur"))
      ;;
    move)
      COMPREPLY=($(compgen -W "left right" -- "$cur"))
      ;;
    slack)
      COMPREPLY=($(compgen -W "start stop" -- "$cur"))
      ;;
  esac
}
complete -F _claudespace claudespace
COMP
}

# --- Main ---

case "${1:-help}" in
  init)         cmd_init ;;
  add)          shift; cmd_add "$@" ;;
  hide)         cmd_hide ;;
  delete)       shift; cmd_delete "$@" ;;
  move)          shift; cmd_move "$@" ;;
  rename)       shift; cmd_rename "$@" ;;
  deploy)       shift; cmd_deploy "$@" ;;
  shrink)       cmd_shrink ;;
  grow)         cmd_grow ;;
  balance)      cmd_balance ;;
  list)         cmd_list ;;
  attach)       cmd_attach ;;
  kill)         cmd_kill ;;
  slack)        shift; cmd_slack "$@" ;;
  connect)      shift; cmd_connect "$@" ;;
  completions)  cmd_completions ;;
  _rebalance)   cmd__rebalance ;;
  _complete)    shift; _cmd_complete "$@" ;;
  help|*)
    cat <<EOF
claudespace — single-window tmux workspace for Claude Code worktrees

Usage:
  claudespace init                  Create session and attach
  claudespace add <name> [branch]   Add a worktree column (claude + shell)
  claudespace add --no-worktree [name]  Add column for repo root (no worktree, default name: main)
  claudespace hide                  Hide current column (kill panes, keep worktree)
  claudespace delete <name>         Delete column, worktree, and branch (prompts y/N)
  claudespace move <left|right>        Move current column left/right (wraps around)
  claudespace rename <name>           Rename current column's panes (claude:<name> + shell:<name>)
  claudespace deploy <target-branch>  Rebase current worktree onto branch and fast-forward merge
  claudespace shrink                Shrink current column to title width
  claudespace grow                  Unshrink current column back to normal width
  claudespace balance               Rebuild the column grid layout (pairs claude+shell, orphans on right)
  claudespace list                  List active worktree columns
  claudespace attach                Attach to the session
  claudespace kill                  Kill the tmux session
  claudespace slack [start|stop]    Start/stop the Slack bridge server
  claudespace connect [name...]     Reconnect columns to Slack bridge threads
  claudespace completions           Output bash completion script

Tab completion:
  Add to your ~/.bashrc or ~/.zshrc:
    eval "\$(claudespace completions)"

Environment:
  CSPACE_SESSION    Session name      (default: claudespace)
  CSPACE_WT_DIR     Worktree parent   (default: ~/.claude-worktrees/<repo>)
EOF
    ;;
esac
